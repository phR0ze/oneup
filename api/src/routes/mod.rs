/*!
 * Axum routes and middleware configuration.
 */
use std::sync::Arc;
use axum::{
    middleware, routing::{get, post, put, delete}, Router
};
use tower_http::{
    cors, trace::TraceLayer,
};

use crate::state;

// Exports
mod health;
mod auth;
mod users;
mod roles;
mod passwords;
mod actions;
mod categories;
mod points;
mod rewards;

/// Configure api routes
pub(crate) fn init(state: Arc::<state::State>) -> Router 
{
    // Disabling CORS across my routes for now
    // TODO: revisit harening this later
    let cors = cors::CorsLayer::new()
        .allow_origin(cors::Any)
        //.allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])
        .allow_methods(cors::Any)
        .allow_headers(cors::Any);
        //.allow_headers([header::CONTENT_TYPE]);

    // No authorization is required for these routes
    let public_routes = Router::new()
        .route("/health", get(health::get))
        .route("/login", post(auth::login))
        .route("/users",get(users::get_all))
        .route("/users/{opt}", get(users::get_by_id))
        .route("/passwords", get(passwords::get))
        .route("/passwords/{opt}", get(passwords::get_by_id))
        .route("/roles", get(roles::get))
        .route("/roles/{opt}", get(roles::get_by_id))
        .route("/categories", get(categories::get))
        .route("/categories/{opt}", get(categories::get_by_id))
        .route("/actions", get(actions::get))
        .route("/actions/{opt}", get(actions::get_by_id))
        .route("/points", get(points::get).post(points::create))
        .route("/points/{opt}",
            get(points::get_by_id).put(points::update_by_id).delete(points::delete_by_id))
        .route("/points/sum", get(points::get_sum))
        .route("/rewards",
            get(rewards::get).post(rewards::create))
        .route("/rewards/{opt}",
            get(rewards::get_by_id).put(rewards::update_by_id).delete(rewards::delete_by_id))
        .route("/users/{opt}/roles", get(users::get_roles));

    // Authorization is required for these routes
    let private_routes = Router::new()
        .route("/users", post(users::create))
        .route("/users/{opt}", put(users::update_by_id).delete(users::delete_by_id))
        .route("/passwords", post(passwords::create))
        .route("/passwords/{opt}", delete(passwords::delete_by_id))
        .route("/roles", post(roles::create))
        .route("/roles/{opt}", put(roles::update_by_id).delete(roles::delete_by_id))
        .route("/categories", post(categories::create))
        .route("/categories/{opt}", put(categories::update_by_id).delete(categories::delete_by_id))
        .route("/actions", post(actions::create))
        .route("/actions/{opt}", put(actions::update_by_id).delete(actions::delete_by_id))
        .layer(middleware::from_fn_with_state(state.clone(), auth::authorization));

    // Merge all routers into the final router
    Router::new()
        .merge(public_routes)
        .merge(private_routes)
        // Add CORS layer to allow cross-origin requests i.e. Swagger UI for development
        .layer(cors)
        // Add the tracing layer for observability
        //.layer(TraceLayer::new_for_http())
        .layer(TraceLayer::new_for_http()
            .make_span_with(|request: &axum::extract::Request| {
                let method = request.method();
                let uri = request.uri();
                tracing::info_span!("http_request", %method, %uri)
            })
            .on_request(|request: &axum::extract::Request, _span: &tracing::Span| {
                tracing::debug!("request started: {} {}", request.method(), request.uri());
            })
            .on_response(|response: &axum::response::Response, latency: std::time::Duration, _span: &tracing::Span| {
                tracing::info!("response completed: {} in {:?}", response.status(), latency);
            })
        )
        // Add the state layer to access application state
        .with_state(state)
}

// -------------------------------------------------------------------------------------------------
// Custom rejection for JSON payloads so that we can return a consistent error response whether it
// was generated by an extractor early on or by application code during the handling of the request.
// -------------------------------------------------------------------------------------------------

// Converts into an `errors::Error` in the extraction rejection path
#[derive(axum::extract::FromRequest)]
#[from_request(via(axum::Json), rejection(crate::errors::Error))]
pub struct Json<T>(T);

// Converts to `IntoResponse` in the positve extraction path
impl<T: serde::Serialize> axum::response::IntoResponse for Json<T> 
{
    fn into_response(self) -> axum::response::Response 
    {
        let Self(value) = self;
        axum::Json(value).into_response()
    }
}

#[cfg(test)]
mod tests 
{
    use super::*;
    use axum::{
        body::Body, http::{header, Method, Request, StatusCode},
    };
    use http_body_util::BodyExt;
    use tower::ServiceExt;
    use crate::{db, model, state};

    // Helper test function to login as the admin user
    pub async fn login_as_admin(state: Arc<state::State>) -> (model::User, String)
    {
        let req = Request::builder().method(Method::POST)
            .uri("/login")
            .header(header::CONTENT_TYPE, "application/json")
            .body(Body::from(serde_json::to_vec(&serde_json::json!(
                model::LoginRequest { handle: "admin".to_string(), password: "admin".to_string() }
            )).unwrap())).unwrap();
        let res = init(state.clone()).oneshot(req).await.unwrap();

        // Validate the response and return then admin user and access token
        assert_eq!(res.status(), StatusCode::OK);
        let bytes = res.into_body().collect().await.unwrap().to_bytes();
        let login_response: model::LoginResponse = serde_json::from_slice(&bytes).unwrap();

        let admin_user = db::user::fetch_by_handle(state.db(), "admin").await.unwrap();
        (admin_user, login_response.access_token)
    }
}